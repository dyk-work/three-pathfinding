!function(e,t){"use strict";class r{static roundNumber(e,t){const r=Math.pow(10,t);return Math.round(e*r)/r}static sample(e){return e[Math.floor(Math.random()*e.length)]}static distanceToSquared(e,t){var r=e.x-t.x,s=e.y-t.y,n=e.z-t.z;return r*r+s*s+n*n}static isPointInPoly(e,t){for(var r=!1,s=-1,n=e.length,o=n-1;++s<n;o=s)(e[s].z<=t.z&&t.z<e[o].z||e[o].z<=t.z&&t.z<e[s].z)&&t.x<(e[o].x-e[s].x)*(t.z-e[s].z)/(e[o].z-e[s].z)+e[s].x&&(r=!r);return r}static isVectorInPolygon(e,t,r){var s=1e5,n=-1e5,o=[];return t.vertexIds.forEach(e=>{s=Math.min(r[e].y,s),n=Math.max(r[e].y,n),o.push(r[e])}),!!(e.y<n+.5&&e.y>s-.5&&this.isPointInPoly(o,e))}static triarea2(e,t,r){var s=t.x-e.x,n=t.z-e.z;return(r.x-e.x)*n-s*(r.z-e.z)}static vequal(e,t){return this.distanceToSquared(e,t)<1e-5}}class s{constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.sinkDown(this.content.length-1)}pop(){const e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.bubbleUp(0)),e}remove(e){const t=this.content.indexOf(e),r=this.content.pop();t!==this.content.length-1&&(this.content[t]=r,this.scoreFunction(r)<this.scoreFunction(e)?this.sinkDown(t):this.bubbleUp(t))}size(){return this.content.length}rescoreElement(e){this.sinkDown(this.content.indexOf(e))}sinkDown(e){const t=this.content[e];for(;e>0;){const r=(e+1>>1)-1,s=this.content[r];if(!(this.scoreFunction(t)<this.scoreFunction(s)))break;this.content[r]=t,this.content[e]=s,e=r}}bubbleUp(e){const t=this.content.length,r=this.content[e],s=this.scoreFunction(r);for(;;){const n=e+1<<1,o=n-1;let i,h=null;if(o<t){const e=this.content[o];i=this.scoreFunction(e),i<s&&(h=o)}if(n<t){const e=this.content[n];this.scoreFunction(e)<(null===h?s:i)&&(h=n)}if(null===h)break;this.content[e]=this.content[h],this.content[h]=r,e=h}}}class n{constructor(){this.portals=[]}push(e,t){void 0===t&&(t=e),this.portals.push({left:e,right:t})}stringPull(){const e=this.portals,t=[];let s,n,o,i=0,h=0,c=0;s=e[0].left,n=e[0].left,o=e[0].right,t.push(s);for(let a=1;a<e.length;a++){const l=e[a].left,u=e[a].right;if(r.triarea2(s,o,u)<=0){if(!(r.vequal(s,o)||r.triarea2(s,n,u)>0)){t.push(n),s=n,i=h,n=s,o=s,h=i,c=i,a=i;continue}o=u,c=a}if(r.triarea2(s,n,l)>=0){if(!(r.vequal(s,n)||r.triarea2(s,o,l)<0)){t.push(o),s=o,i=c,n=s,o=s,h=i,c=i,a=i;continue}n=l,h=a}}return 0!==t.length&&r.vequal(t[t.length-1],e[e.length-1].left)||t.push(e[e.length-1].left),this.path=t,t}}class o{constructor(){this.zones={}}static createZone(e){return e.isGeometry?console.warn("[three-pathfinding]: Use BufferGeometry, not Geometry, to create zone."):e=(new t.Geometry).fromBufferGeometry(e),class{static buildZone(e){const s=this._buildNavigationMesh(e),n={};s.vertices.forEach(e=>{e.x=r.roundNumber(e.x,2),e.y=r.roundNumber(e.y,2),e.z=r.roundNumber(e.z,2)}),n.vertices=s.vertices;const o=this._buildPolygonGroups(s);return n.groups=new Array(o.length),o.forEach((e,s)=>{const o=new Map;e.forEach((e,t)=>{o.set(e,t)});const i=new Array(e.length);e.forEach((e,s)=>{const h=[];e.neighbours.forEach(e=>h.push(o.get(e)));const c=[];e.neighbours.forEach(t=>c.push(this._getSharedVerticesInOrder(e,t)));const a=new t.Vector3(0,0,0);a.add(n.vertices[e.vertexIds[0]]),a.add(n.vertices[e.vertexIds[1]]),a.add(n.vertices[e.vertexIds[2]]),a.divideScalar(3),a.x=r.roundNumber(a.x,2),a.y=r.roundNumber(a.y,2),a.z=r.roundNumber(a.z,2),i[s]={id:s,neighbours:h,vertexIds:e.vertexIds,centroid:a,portals:c}}),n.groups[s]=i}),n}static _buildNavigationMesh(e){return e.mergeVertices(),this._buildPolygonsFromGeometry(e)}static _buildPolygonGroups(e){const t=e.polygons,r=[],s=function(e){e.neighbours.forEach(t=>{void 0===t.group&&(t.group=e.group,s(t))})};return t.forEach(e=>{void 0!==e.group?r[e.group].push(e):(e.group=r.length,s(e),r.push([e]))}),r}static _buildPolygonNeighbours(e,t){const r=new Set,s=t[e.vertexIds[0]],n=t[e.vertexIds[1]],o=t[e.vertexIds[2]];return s.forEach(t=>{t!==e&&(n.includes(t)||o.includes(t))&&r.add(t)}),n.forEach(t=>{t!==e&&o.includes(t)&&r.add(t)}),r}static _buildPolygonsFromGeometry(e){const t=[],r=e.vertices,s=new Array(r.length);for(let e=0;e<r.length;e++)s[e]=[];return e.faces.forEach(e=>{const r={vertexIds:[e.a,e.b,e.c],neighbours:null};t.push(r),s[e.a].push(r),s[e.b].push(r),s[e.c].push(r)}),t.forEach(e=>{e.neighbours=this._buildPolygonNeighbours(e,s)}),{polygons:t,vertices:r}}static _getSharedVerticesInOrder(e,t){const r=e.vertexIds,s=r[0],n=r[1],o=r[2],i=t.vertexIds,h=i.includes(s),c=i.includes(n),a=i.includes(o);return h&&c&&a?Array.from(r):h&&c?[s,n]:c&&a?[n,o]:h&&a?[o,s]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}.buildZone(e)}setZoneData(e,t){this.zones[e]=t}getRandomNode(e,s,n,o){if(!this.zones[e])return new t.Vector3;n=n||null,o=o||0;const i=[];return this.zones[e].groups[s].forEach(e=>{n&&o?r.distanceToSquared(n,e.centroid)<o*o&&i.push(e.centroid):i.push(e.centroid)}),r.sample(i)||new t.Vector3}getClosestNode(e,t,s,n=!1){const o=this.zones[t].groups[s],i=this.zones[t].vertices;let h=null,c=1/0;return o.forEach(t=>{const s=r.distanceToSquared(t.centroid,e);s<c&&(!n||r.isVectorInPolygon(e,t,i))&&(h=t,c=s)}),h}findPath(e,o,i,h){const c=this.zones[i].groups[h],a=this.zones[i].vertices,l=this.getClosestNode(e,i,h,!0),u=this.getClosestNode(o,i,h,!0);if(!l||!u)return null;const d=class{static init(e){for(let t=0;t<e.length;t++){const r=e[t];r.f=0,r.g=0,r.h=0,r.cost=1,r.visited=!1,r.closed=!1,r.parent=null}}static cleanUp(e){for(let t=0;t<e.length;t++){const r=e[t];delete r.f,delete r.g,delete r.h,delete r.cost,delete r.visited,delete r.closed,delete r.parent}}static heap(){return new s((function(e){return e.f}))}static search(e,t,r){this.init(e);const s=this.heap();for(s.push(t);s.size()>0;){const t=s.pop();if(t===r){let e=t;const r=[];for(;e.parent;)r.push(e),e=e.parent;return this.cleanUp(r),r.reverse()}t.closed=!0;const n=this.neighbours(e,t);for(let e=0,o=n.length;e<o;e++){const o=n[e];if(o.closed)continue;const i=t.g+o.cost,h=o.visited;if(!h||i<o.g){if(o.visited=!0,o.parent=t,!o.centroid||!r.centroid)throw new Error("Unexpected state");o.h=o.h||this.heuristic(o.centroid,r.centroid),o.g=i,o.f=o.g+o.h,h?s.rescoreElement(o):s.push(o)}}}return[]}static heuristic(e,t){return r.distanceToSquared(e,t)}static neighbours(e,t){const r=[];for(let s=0;s<t.neighbours.length;s++)r.push(e[t.neighbours[s]]);return r}}.search(c,l,u),p=function(e,t){for(var r=0;r<e.neighbours.length;r++)if(e.neighbours[r]===t.id)return e.portals[r]},g=new n;g.push(e);for(let e=0;e<d.length;e++){const t=d[e],r=d[e+1];if(r){const e=p(t,r);g.push(a[e[0]],a[e[1]])}}g.push(o),g.stringPull();const f=g.path.map(e=>new t.Vector3(e.x,e.y,e.z));return f.shift(),f}}o.prototype.getGroup=function(){const e=new t.Plane;return function(t,s,n=!1){if(!this.zones[t])return null;let o=null,i=Math.pow(50,2);const h=this.zones[t];for(let t=0;t<h.groups.length;t++){const c=h.groups[t];for(const a of c){if(n&&(e.setFromCoplanarPoints(h.vertices[a.vertexIds[0]],h.vertices[a.vertexIds[1]],h.vertices[a.vertexIds[2]]),Math.abs(e.distanceToPoint(s))<.01)){const e=[h.vertices[a.vertexIds[0]],h.vertices[a.vertexIds[1]],h.vertices[a.vertexIds[2]]];if(r.isPointInPoly(e,s))return t}const c=r.distanceToSquared(a.centroid,s);c<i&&(o=t,i=c)}}return o}}(),o.prototype.clampStep=function(){const e=new t.Vector3,r=new t.Plane,s=new t.Triangle,n=new t.Vector3;let o,i,h=new t.Vector3;return function(t,c,a,l,u,d){const p=this.zones[l].vertices,g=this.zones[l].groups[u],f=[a],v={};v[a.id]=0,o=void 0,h.set(0,0,0),i=1/0,r.setFromCoplanarPoints(p[a.vertexIds[0]],p[a.vertexIds[1]],p[a.vertexIds[2]]),r.projectPoint(c,e),n.copy(e);for(let t=f.pop();t;t=f.pop()){s.set(p[t.vertexIds[0]],p[t.vertexIds[1]],p[t.vertexIds[2]]),s.closestPointToPoint(n,e),e.distanceToSquared(n)<i&&(o=t,h.copy(e),i=e.distanceToSquared(n));const r=v[t.id];if(!(r>2))for(let e=0;e<t.neighbours.length;e++){const s=g[t.neighbours[e]];s.id in v||(f.push(s),v[s.id]=r+1)}}return d.copy(h),o}}();const i={PLAYER:new t.Color(15631215).convertGammaToLinear(2.2).getHex(),TARGET:new t.Color(14469912).convertGammaToLinear(2.2).getHex(),PATH:new t.Color(41903).convertGammaToLinear(2.2).getHex(),WAYPOINT:new t.Color(41903).convertGammaToLinear(2.2).getHex(),CLAMPED_STEP:new t.Color(14472114).convertGammaToLinear(2.2).getHex(),CLOSEST_NODE:new t.Color(4417387).convertGammaToLinear(2.2).getHex()};class h extends t.Object3D{constructor(){super(),this._playerMarker=new t.Mesh(new t.SphereGeometry(.25,32,32),new t.MeshBasicMaterial({color:i.PLAYER})),this._targetMarker=new t.Mesh(new t.BoxGeometry(.3,.3,.3),new t.MeshBasicMaterial({color:i.TARGET})),this._nodeMarker=new t.Mesh(new t.BoxGeometry(.1,.8,.1),new t.MeshBasicMaterial({color:i.CLOSEST_NODE})),this._stepMarker=new t.Mesh(new t.BoxGeometry(.1,1,.1),new t.MeshBasicMaterial({color:i.CLAMPED_STEP})),this._pathMarker=new t.Object3D,this._pathLineMaterial=new t.LineBasicMaterial({color:i.PATH,linewidth:2}),this._pathPointMaterial=new t.MeshBasicMaterial({color:i.WAYPOINT}),this._pathPointGeometry=new t.SphereBufferGeometry(.08),this._markers=[this._playerMarker,this._targetMarker,this._nodeMarker,this._stepMarker,this._pathMarker],this._markers.forEach(e=>{e.visible=!1,this.add(e)})}setPath(e){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);e=[this._playerMarker.position].concat(e);const r=new t.Geometry;for(let s=0;s<e.length;s++)r.vertices.push(e[s].clone().add(new t.Vector3(0,.2,0)));this._pathMarker.add(new t.Line(r,this._pathLineMaterial));for(let r=0;r<e.length-1;r++){const s=new t.Mesh(this._pathPointGeometry,this._pathPointMaterial);s.position.copy(e[r]),s.position.y+=.2,this._pathMarker.add(s)}return this._pathMarker.visible=!0,this}setPlayerPosition(e){return this._playerMarker.position.copy(e),this._playerMarker.visible=!0,this}setTargetPosition(e){return this._targetMarker.position.copy(e),this._targetMarker.visible=!0,this}setNodePosition(e){return this._nodeMarker.position.copy(e),this._nodeMarker.visible=!0,this}setStepPosition(e){return this._stepMarker.position.copy(e),this._stepMarker.visible=!0,this}reset(){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);return this._markers.forEach(e=>{e.visible=!1}),this}}e.Pathfinding=o,e.PathfindingHelper=h}({},THREE);
//# sourceMappingURL=three-pathfinding.js.map
